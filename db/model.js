/*
set without merge will overwrite a document or create it if it doesn't exist yet

set with merge will update fields in the document or create it if it doesn't exists

update will update fields but will fail if the document doesn't exist
*/

import { uuid } from 'uuidv4';

function attach_common_attributes(data) {
  let _date = new Date();
  if (!data.created_at) {
    data.created_at = new Date(_date.getTime());
  }

  data.updated_at = new Date(_date.getTime());
}

class Model {
  static Build(data) {
    return Object.assign(new this(), data)
  }

  static get_col_ref() {
    throw "Should be implemented by subclass";
  }


  static attach_unique_id(data) {
    if (data.id) {
      throw new Error(`id is autogenerated, can't take supplied ${data.id}, you may consider ModelCustomDocId`);
    }
    data.id = uuid();
    return data;
  }

  /* alias for create */
  static async add(data) {
    return await this.create(data);
  }

  /* Creates a new document */
  static async create(data, id) {

    attach_common_attributes(data);
    await this.schema.validateAsync(data);

    if (!id) {
      data = this.attach_unique_id(data);
      id = data.id
    }

    if (this.beforeCreateHook) {
      await this.beforeCreateHook(data);
    }
    await this.get_col_ref().doc(id).create(data);
    if (this.afterCreateHook) {
      await this.afterCreateHook(data);
    }
    return data;
  }

  static async plain_create(data) {
    attach_common_attributes(data);
    // Validate & normalize schema
    await this.schema.validateAsync(data)
    this.attach_unique_id(data);

    await this.get_col_ref().doc(data.id).create(data);
    if (this.afterCreateHook) {
      await this.afterCreateHook(data);
    }
    return data;
  }

  static async plain_create_with_mysql_id(data) {
    attach_common_attributes(data);
    // Validate & normalize schema
    // await this.schema.validateAsync(data)
    if (!data.id) {
      console.log(`Error no id exists ${data}`)
      // throw new Error(`mysql id is required for ${data} this method is ment for existing users for new user use plain_create`);
      return;
    }

    await this.get_col_ref().doc(data.id).set(data, { merge: true });
    return data;
  }

  static async batch_create(batch_ref, data) {
    attach_common_attributes(data);
    this.attach_unique_id(data);
    await batch_ref.create(this.get_col_ref().doc(data.id), data);
    return data;
  }

  /* will update fields but will fail if the document doesn't exist */
  static async update(id, data, is_merge) {
    data.id = id;

    var _db_data = {};
    let data_doc = await this.get_col_ref().doc(id).get();
    if (!data_doc.exists) {
      return _db_data
    }

    _db_data = data_doc.data();
    if (this.beforeUpdateHook) {
      await this.beforeUpdateHook({ ..._db_data, ...data });
    }

    if (is_merge) {
      await this.get_col_ref().doc(id).update(data, { merge: true });
    } else {
      await this.get_col_ref().doc(id).update(data);
    }

    _db_data = { ..._db_data, ...data }
    if (this.afterUpdateHook) {
      await this.afterUpdateHook(_db_data);
    }

    return _db_data;
  }

  static async tx_update(tx, doc_ref_in_tx, data, shouldTriggerBeforeUpdateHook, shouldTriggerAfterUpdateHook) {
    data.updated_at = new Date();

    shouldTriggerBeforeUpdateHook = (shouldTriggerBeforeUpdateHook == null || shouldTriggerBeforeUpdateHook == undefined) ? true : shouldTriggerBeforeUpdateHook;
    shouldTriggerAfterUpdateHook = (shouldTriggerAfterUpdateHook == null || shouldTriggerAfterUpdateHook == undefined) ? true : shouldTriggerAfterUpdateHook;

    if (shouldTriggerBeforeUpdateHook && this.beforeUpdateHook) {
      await this.beforeUpdateHook(data);
    }

    tx.update(doc_ref_in_tx, data);

    if (shouldTriggerAfterUpdateHook && this.afterUpdateHook) {
      await this.afterUpdateHook(data);
    }

    return data;
  }


  /* set will overwrite a document or create it if it doesn't exist yet */
  static async set(id, data) {
    attach_common_attributes(data);
    if (this.beforeSetHook) {
      await this.beforeSetHook(id, data);
    }
    await this.get_col_ref().doc(`${id}`).set(data, { merge: true });
    if (this.afterSetHook) {
      await this.afterSetHook(id, data);
    }
    return data;
  }

  /* 
    This medthod is intended to be used within runTransaction.
  */
  static async tx_set(tx, doc_ref_in_tx, data) {
    attach_common_attributes(data);
    if (!data.id) {
      this.attach_unique_id(data);
    }
    if (this.beforeSetHook) {
      await this.beforeUpdateHook(data);
    }
    tx.set(doc_ref_in_tx, data);
    if (this.afterSetHook) {
      await this.afterUpdateHook(data);
    }
    return data;
  }

  static async tx_delete(tx, doc_ref_in_tx) {
    if (this.beforeDeleteHook) {
      await this.beforeDeleteHook(tx, doc_ref_in_tx);
    }
    tx.delete(doc_ref_in_tx);
    if (this.afterDeleteHook) {
      await this.afterDeleteHook(tx, doc_ref_in_tx);
    }
  }

  /* Alias for set, this is used when id is not known*/
  static async upsert(data) {
    attach_common_attributes(data);
    await this.schema.validateAsync(data);

    this.attach_unique_id(data);

    if (this.beforeUpdateHook) {
      await this.beforeUpdateHook(data);
    }

    await this.get_col_ref().doc(`${data.id}`).set(data, { merge: true });
    if (this.afterUpdateHook) {
      await this.afterUpdateHook(data);
    }
    return data;
  }

  /* merge fields in the document or create it if it doesn't exists */
  static async merge_or_insert(id, data) {
    attach_common_attributes(data);

    if (this.beforeSaveHook) {
      await this.beforeSaveHook(data);
    }
    await this.get_col_ref().doc(id).set(data, { merge: true });
    if (this.afterSaveHook) {
      await this.afterSaveHook(data);
    }
    return data;
  }

  static async delete(id) {
    if (this.beforeDeleteHook) {
      await this.beforeDeleteHook(id);
    }
    await this.get_col_ref().doc(id).delete();
    if (this.afterDeleteHook) {
      await this.afterDeleteHook(id);
    }
    return true;
  }

  static get_doc_ref_for_id(id) {
    return this.get_col_ref().doc(id);
  }

  static async get_by_id(id) {
    if (!id) {
      return;
    }
    let _snap = await this.get_col_ref().doc(id).get();
    if (_snap.empty) {
      return null;
    }
    return _snap.data();
  }
}

Model.ErrorCodes = {
  /* See
  https://github.com/googleapis/nodejs-firestore/issues/602
  https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
  */
  NOT_FOUND: 5,
  ALREADY_EXISTS: 6
}

export default Model;
